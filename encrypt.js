// Generated by CoffeeScript 1.7.1
(function() {
  var EVP_BytesToKey, Encryptor, bytes_to_key_results, cachedTables, encrypt, int32Max, method_supported;

  int32Max = Math.pow(2, 32);

  cachedTables = {};

  window.getTable = function(key) {
    var ah, al, decrypt_table, i, md5sum, md5sum_array, md5sum_str, result, table, _i;
    if (cachedTables[key]) {
      return cachedTables[key];
    }
    console.log("calculating ciphers");
    table = new Array(256);
    decrypt_table = new Array(256);
    md5sum_str = rstr_md5(key);
    md5sum = new ArrayBuffer(8);
    md5sum_array = new Uint8Array(md5sum, 0, 8);
    for (i = _i = 0; _i <= 7; i = ++_i) {
      md5sum_array[i] = md5sum_str.charCodeAt(i);
    }
    al = new Uint32Array(md5sum, 0, 1)[0];
    ah = new Uint32Array(md5sum, 4, 1)[0];
    i = 0;
    while (i < 256) {
      table[i] = i;
      i++;
    }
    i = 1;
    while (i < 1024) {
      table = merge_sort(table, function(x, y) {
        return ((ah % (x + i)) * int32Max + al) % (x + i) - ((ah % (y + i)) * int32Max + al) % (y + i);
      });
      i++;
    }
    i = 0;
    while (i < 256) {
      decrypt_table[table[i]] = i;
      ++i;
    }
    result = [table, decrypt_table];
    cachedTables[key] = result;
    return result;
  };

  encrypt = function(table, buf) {
    var array, i;
    i = 0;
    array = new Uint8Array(buf);
    while (i < array.length) {
      array[i] = table[array[i]];
      i++;
    }
    return buf;
  };

  bytes_to_key_results = {};

  EVP_BytesToKey = function(password, key_len, iv_len) {
    var count, d, data, i, iv, key, m, md5, ms;
    if (bytes_to_key_results[password]) {
      return bytes_to_key_results[password];
    }
    m = [];
    i = 0;
    count = 0;
    while (count < key_len + iv_len) {
      md5 = forge.md.md5.create();
      data = password;
      if (i > 0) {
        data = [m[i - 1] + password];
      }
      md5.update(data);
      d = md5.digest().bytes();
      m.push(d);
      count += d.length;
      i += 1;
    }
    ms = m.join('');
    key = ms.slice(0, key_len);
    iv = ms.slice(key_len, key_len + iv_len);
    bytes_to_key_results[password] = [key, iv];
    return [key, iv];
  };

  method_supported = {
    'aes-128-cfb': [16, 16, 'AES-CFB'],
    'aes-192-cfb': [24, 16, 'AES-CFB'],
    'aes-256-cfb': [32, 16, 'AES-CFB']
  };

  Encryptor = (function() {
    function Encryptor(key, method) {
      var _ref;
      this.key = key;
      this.method = method;
      this.iv_sent = false;
      if (this.method === 'table') {
        this.method = null;
      }
      if (this.method != null) {
        this.cipher = this.get_cipher(this.key, this.method, 1, forge.random.getBytesSync(32));
      } else {
        _ref = getTable(this.key), this.encryptTable = _ref[0], this.decryptTable = _ref[1];
      }
    }

    Encryptor.prototype.get_cipher_len = function(method) {
      var m;
      method = method.toLowerCase();
      m = method_supported[method];
      return m;
    };

    Encryptor.prototype.get_cipher = function(password, method, op, iv) {
      var cipher, decipher, iv_, key, m, _ref;
      method = method.toLowerCase();
      m = this.get_cipher_len(method);
      if (m != null) {
        _ref = EVP_BytesToKey(password, m[0], m[1]), key = _ref[0], iv_ = _ref[1];
        if (iv == null) {
          iv = iv_;
        }
        if (op === 1) {
          this.cipher_iv = iv.slice(0, m[1]);
        }
        iv = iv.slice(0, m[1]);
        if (op === 1) {
          cipher = forge.cipher.createCipher(method, key);
          cipher.start({
            iv: iv
          });
          return cipher;
        } else {
          decipher = forge.createCipher(method, key);
          cipher.start({
            iv: iv
          });
          return decipher;
        }
      }
    };

    Encryptor.prototype.encrypt = function(buf) {
      var result;
      if (this.method != null) {
        result = this.cipher.update(buf.toString('binary'));
        if (this.iv_sent) {
          return result;
        } else {
          this.iv_sent = true;
          return this.cipher_iv + result;
        }
      } else {
        return substitute(this.encryptTable, buf);
      }
    };

    Encryptor.prototype.decrypt = function(buf) {
      var decipher_iv, decipher_iv_len, result;
      if (this.method != null) {
        if (this.decipher == null) {
          decipher_iv_len = this.get_cipher_len(this.method)[1];
          decipher_iv = buf.slice(0, decipher_iv_len);
          this.decipher = this.get_cipher(this.key, this.method, 0, decipher_iv);
          result = to_buffer(this.decipher.update(buf.slice(decipher_iv_len).toString('binary')));
          return result;
        } else {
          result = to_buffer(this.decipher.update(buf.toString('binary')));
          return result;
        }
      } else {
        return substitute(this.decryptTable, buf);
      }
    };

    return Encryptor;

  })();

  window.Encryptor = Encryptor;

}).call(this);
