// Generated by CoffeeScript 1.7.1
(function() {
  var EVP_BytesToKey, Encryptor, bytes_to_key_results, cachedTables, createCipher, encrypt, int32Max, method_supported, string2Uint8Array, uint82String;

  int32Max = Math.pow(2, 32);

  cachedTables = {};

  window.getTable = function(key) {
    var ah, al, decrypt_table, i, md5sum, md5sum_array, md5sum_str, result, table, _i;
    if (cachedTables[key]) {
      return cachedTables[key];
    }
    console.log("calculating ciphers");
    table = new Array(256);
    decrypt_table = new Array(256);
    md5sum_str = rstr_md5(key);
    md5sum = new ArrayBuffer(8);
    md5sum_array = new Uint8Array(md5sum, 0, 8);
    for (i = _i = 0; _i <= 7; i = ++_i) {
      md5sum_array[i] = md5sum_str.charCodeAt(i);
    }
    al = new Uint32Array(md5sum, 0, 1)[0];
    ah = new Uint32Array(md5sum, 4, 1)[0];
    i = 0;
    while (i < 256) {
      table[i] = i;
      i++;
    }
    i = 1;
    while (i < 1024) {
      table = merge_sort(table, function(x, y) {
        return ((ah % (x + i)) * int32Max + al) % (x + i) - ((ah % (y + i)) * int32Max + al) % (y + i);
      });
      i++;
    }
    i = 0;
    while (i < 256) {
      decrypt_table[table[i]] = i;
      ++i;
    }
    result = [table, decrypt_table];
    cachedTables[key] = result;
    return result;
  };

  encrypt = function(table, buf) {
    var array, i;
    i = 0;
    array = new Uint8Array(buf);
    while (i < array.length) {
      array[i] = table[array[i]];
      i++;
    }
    return buf;
  };

  bytes_to_key_results = {};

  string2Uint8Array = function(string) {
    var arr, i, _i, _ref;
    arr = new Uint8Array(string.length);
    for (i = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      arr[i] = string.charCodeAt(i);
    }
    return arr;
  };

  uint82String = function(arr) {
    return String.fromCharCode.apply(null, arr);
  };

  EVP_BytesToKey = function(password, key_len, iv_len) {
    var count, d, data, i, iv, key, m, md5, ms;
    if (bytes_to_key_results[password]) {
      return bytes_to_key_results[password];
    }
    m = [];
    i = 0;
    count = 0;
    while (count < key_len + iv_len) {
      md5 = forge.md.md5.create();
      data = password;
      if (i > 0) {
        data = [m[i - 1] + password];
      }
      md5.update(data);
      d = md5.digest().bytes();
      m.push(d);
      count += d.length;
      i += 1;
    }
    ms = m.join('');
    key = ms.slice(0, key_len);
    iv = ms.slice(key_len, key_len + iv_len);
    bytes_to_key_results[password] = [key, iv];
    return [key, iv];
  };

  method_supported = {
    'rc4-md5': [32, 16, 'RC4-MD5']
  };

  createCipher = function(method, key, iv, op) {
    var md, rc4_key;
    if (method === 'rc4-md5') {
      md = forge.md.md5.create();
      md.update(key);
      md.update(uint82String(iv));
      rc4_key = string2Uint8Array(md.digest().data);
      return RC4(rc4_key);
    } else {
      throw new Error("unknown cipher " + method);
    }
  };

  Encryptor = (function() {
    function Encryptor(key, method) {
      var _ref;
      this.key = key;
      this.method = method;
      this.iv_sent = false;
      if (this.method === 'table') {
        this.method = null;
      }
      if (this.method != null) {
        this.cipher = this.get_cipher(this.key, this.method, 1, string2Uint8Array(forge.random.getBytesSync(32)));
      } else {
        _ref = getTable(this.key), this.encryptTable = _ref[0], this.decryptTable = _ref[1];
      }
    }

    Encryptor.prototype.get_cipher_len = function(method) {
      var m;
      method = method.toLowerCase();
      m = method_supported[method];
      return m;
    };

    Encryptor.prototype.get_cipher = function(password, method, op, iv) {
      var iv_, key, m, _ref;
      method = method.toLowerCase();
      m = this.get_cipher_len(method);
      if (m != null) {
        _ref = EVP_BytesToKey(password, m[0], m[1]), key = _ref[0], iv_ = _ref[1];
        iv = iv.subarray(0, m[1]);
        if (op === 1) {
          this.cipher_iv = iv;
        }
        return createCipher(method, key, iv, op);
      }
    };

    Encryptor.prototype.encrypt = function(buf) {
      var combined, iv_len, len, result;
      if (this.method != null) {
        len = buf.byteLength;
        result = new Uint8Array(len);
        this.cipher.update(result, buf, len);
        if (this.iv_sent) {
          return result.buffer;
        } else {
          this.iv_sent = true;
          iv_len = this.cipher_iv.byteLength;
          combined = new Uint8Array(iv_len + len);
          combined.set(this.cipher_iv, 0);
          combined.set(result, iv_len);
          return combined.buffer;
        }
      } else {
        return substitute(this.encryptTable, buf);
      }
    };

    Encryptor.prototype.decrypt = function(buf) {
      var decipher_iv, decipher_iv_len, len, result;
      if (this.method != null) {
        if (this.decipher == null) {
          decipher_iv_len = this.get_cipher_len(this.method)[1];
          decipher_iv = buf.subarray(0, decipher_iv_len);
          this.decipher = this.get_cipher(this.key, this.method, 0, decipher_iv);
          result = new Uint8Array(buf.byteLength);
          this.decipher.update(buf.subarray(decipher_iv_len));
          return result.buffer;
        } else {
          len = buf.byteLength;
          result = new Uint8Array(len);
          this.decipher.update(result, buf, len);
          return result.buffer;
        }
      } else {
        return substitute(this.decryptTable, buf);
      }
    };

    return Encryptor;

  })();

  window.Encryptor = Encryptor;

}).call(this);
