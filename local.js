// Generated by CoffeeScript 1.4.0
(function() {
  var BUF_SIZE, KEY, METHOD, PORT, REMOTE_PORT, SERVER, config, getServer, inetAton, inetNtoa, socket, string2ArrayBuffer, timeout;

  inetNtoa = function(buf) {
    return buf[0] + "." + buf[1] + "." + buf[2] + "." + buf[3];
  };

  inetAton = function(ipStr) {
    var buf, i, parts;
    parts = ipStr.split(".");
    if (parts.length !== 4) {
      return null;
    } else {
      buf = new Buffer(4);
      i = 0;
      while (i < 4) {
        buf[i] = +parts[i];
        i++;
      }
      return buf;
    }
  };

  config = {
    local_port: 1081,
    server_port: 8388,
    password: 'barfoo!',
    server: '127.0.0.1',
    method: null
  };

  SERVER = config.server;

  REMOTE_PORT = config.server_port;

  PORT = config.local_port;

  KEY = config.password;

  METHOD = config.method;

  timeout = Math.floor(config.timeout * 1000);

  BUF_SIZE = 1500;

  getServer = function() {
    if (SERVER instanceof Array) {
      return SERVER[Math.floor(Math.random() * SERVER.length)];
    } else {
      return SERVER;
    }
  };

  string2ArrayBuffer = function(string) {
    var arr, buf, i, _i, _ref;
    buf = new ArrayBuffer(string.length);
    arr = new Uint8Array(buf, 0, string.length);
    for (i = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
      arr[i] = string.charCodeAt(i);
    }
    return buf;
  };

  socket = chrome.socket;

  socket.create('tcp', {}, function(socketInfo) {
    var address, listen, port;
    listen = socketInfo.socketId;
    console.log("listen: " + listen);
    address = '0.0.0.0';
    port = PORT;
    chrome.runtime.onSuspend.addListener(function() {
      console.log('closing listen socket');
      return chrome.socket.destroy(listen);
    });
    return socket.listen(listen, address, port, function(result) {
      console.log('listen');
      console.assert(0 === result);
      return socket.getInfo(listen, function(info) {
        var accept;
        console.log('server listening on http://localhost:' + info.localPort);
        accept = function(acceptInfo) {
          var encryptor, local;
          socket.accept(listen, accept);
          console.log('socket.accept');
          console.assert(acceptInfo.resultCode === 0);
          local = acceptInfo.socketId;
          console.log("accept " + local);
          encryptor = new Encryptor(KEY, METHOD);
          return socket.create('tcp', {}, function(socketInfo) {
            var remote;
            remote = socketInfo.socketId;
            return socket.connect(remote, SERVER, REMOTE_PORT, function(result) {
              console.log("connect " + remote);
              if (result !== 0) {
                console.log("destroy " + local + " " + remote);
                socket.destroy(local);
                socket.destroy(remote);
                return;
              }
              console.assert(0 === result);
              return socket.read(local, 256, function(readInfo) {
                console.assert(readInfo.resultCode > 0);
                return socket.write(local, string2ArrayBuffer('\x05\x00'), function(readInfo) {
                  console.assert(readInfo.bytesWritten === 2);
                  return socket.read(local, 3, function(readInfo) {
                    console.assert(readInfo.resultCode > 0);
                    return socket.write(local, string2ArrayBuffer('\x05\x00\x00\x01\x00\x00\x00\x00\x00\x00'), function(readInfo) {
                      var localToRemote, remoteToLocal;
                      console.assert(readInfo.bytesWritten === 10);
                      localToRemote = function(readInfo) {
                        var data;
                        if (readInfo.resultCode <= 0) {
                          console.log("destroy " + local + " " + remote);
                          socket.destroy(local);
                          socket.destroy(remote);
                          return;
                        }
                        console.assert(readInfo.resultCode > 0);
                        data = readInfo.data;
                        data = encryptor.encrypt(data);
                        return socket.write(remote, data, function(readInfo) {
                          if (readInfo.bytesWritten <= 0) {
                            console.log("destroy " + local + " " + remote);
                            socket.destroy(local);
                            socket.destroy(remote);
                            return;
                          }
                          console.assert(readInfo.bytesWritten === data.byteLength);
                          return socket.read(local, BUF_SIZE, localToRemote);
                        });
                      };
                      remoteToLocal = function(readInfo) {
                        var data;
                        if (readInfo.resultCode <= 0) {
                          console.log("destroy " + local + " " + remote);
                          socket.destroy(remote);
                          socket.destroy(local);
                          return;
                        }
                        console.assert(readInfo.resultCode > 0);
                        data = readInfo.data;
                        data = encryptor.decrypt(data);
                        return socket.write(local, data, function(readInfo) {
                          if (readInfo.bytesWritten <= 0) {
                            console.log("destroy " + local + " " + remote);
                            socket.destroy(local);
                            socket.destroy(remote);
                            return;
                          }
                          console.assert(readInfo.bytesWritten === data.byteLength);
                          return socket.read(remote, BUF_SIZE, remoteToLocal);
                        });
                      };
                      socket.read(local, BUF_SIZE, localToRemote);
                      return socket.read(remote, BUF_SIZE, remoteToLocal);
                    });
                  });
                });
              });
            });
          });
        };
        return socket.accept(listen, accept);
      });
    });
  });

}).call(this);
