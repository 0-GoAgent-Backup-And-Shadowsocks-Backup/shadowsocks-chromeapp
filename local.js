// Generated by CoffeeScript 1.7.1
(function() {
  var Local, errorRedirector, read, receiveCallbacks, receiveRedirector, tcp, tcpServer;

  tcpServer = chrome.sockets.tcpServer;

  tcp = chrome.sockets.tcp;

  receiveCallbacks = {};

  read = function(sockId, callback) {
    receiveCallbacks[sockId] = callback;
    return tcp.setPaused(sockId, false);
  };

  receiveRedirector = function(info) {
    return receiveCallbacks[info.socketId](info.data, null);
  };

  errorRedirector = function(info) {
    return receiveCallbacks[info.socketId](null, info.resultCode);
  };

  tcp.onReceive.addListener(receiveRedirector);

  tcp.onReceiveError.addListener(errorRedirector);

  Local = (function() {
    function Local(config) {
      var BUF_SIZE, KEY, METHOD, PORT, REMOTE_PORT, SERVER, string2ArrayBuffer, that;
      SERVER = config.server;
      REMOTE_PORT = +config.server_port;
      PORT = +config.local_port;
      KEY = config.password;
      METHOD = config.method;
      BUF_SIZE = 1500;
      that = this;
      string2ArrayBuffer = function(string) {
        var arr, buf, i, _i, _ref;
        buf = new ArrayBuffer(string.length);
        arr = new Uint8Array(buf, 0, string.length);
        for (i = _i = 0, _ref = string.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
          arr[i] = string.charCodeAt(i);
        }
        return buf;
      };
      tcpServer.create({}, function(socketInfo) {
        var address, listen, port;
        that.listen = socketInfo.socketId;
        listen = that.listen;
        console.log("listen: " + listen);
        address = '0.0.0.0';
        port = PORT;
        chrome.runtime.onSuspend.addListener(function() {
          console.log('closing listen socket');
          return chrome.tcpServer.close(listen);
        });
        return tcpServer.listen(listen, address, port, function(result) {
          console.log('listen');
          return tcpServer.getInfo(listen, function(info) {
            var accept;
            console.log('server listening on localhost:' + info.localPort);
            accept = function(acceptInfo) {
              var encryptor, local;
              console.log('accepted');
              if (acceptInfo.clientSocketId === 0) {
                return;
              }
              local = acceptInfo.clientSocketId;
              console.log("accept " + local);
              encryptor = new Encryptor(KEY, METHOD);
              return tcp.create({}, function(socketInfo) {
                var remote;
                remote = socketInfo.socketId;
                return tcp.connect(remote, SERVER, REMOTE_PORT, function(result) {
                  console.log("connect " + remote);
                  if (result !== 0) {
                    console.log("close " + local + " " + remote);
                    tcp.close(local);
                    tcp.close(remote);
                    delete receiveCallbacks[local];
                    delete receiveCallbacks[remote];
                    return;
                  }
                  tcp.setPaused(remote, true);
                  return read(local, function(data, error) {
                    console.log('read 1');
                    console.log(data.byteLength);
                    return tcp.send(local, string2ArrayBuffer('\x05\x00'), function(readInfo) {
                      console.log('send 1');
                      console.log(data.byteLength);
                      console.assert(readInfo.bytesSent === 2);
                      return read(local, function(data, error) {
                        var addrToSend;
                        console.log('read 2');
                        console.log(data.byteLength);
                        addrToSend = new Uint8Array(data).subarray(3);
                        console.assert(readInfo.resultCode > 0);
                        return tcp.send(local, string2ArrayBuffer('\x05\x00\x00\x01\x00\x00\x00\x00\x00\x00'), function(readInfo) {
                          var localToRemote, remoteToLocal;
                          console.log('send 2');
                          console.assert(readInfo.bytesSent === 10);
                          localToRemote = function(data, error) {
                            var tmp;
                            if (error) {
                              console.log("close " + local + " " + remote);
                              tcp.close(local);
                              tcp.close(remote);
                              delete receiveCallbacks[local];
                              delete receiveCallbacks[remote];
                              return;
                            }
                            if (addrToSend) {
                              tmp = new Uint8Array(data.byteLength + addrToSend.byteLength);
                              tmp.set(addrToSend, 0);
                              tmp.set(new Uint8Array(data), addrToSend.byteLength);
                              addrToSend = null;
                              data = tmp;
                            }
                            data = encryptor.encrypt(data);
                            return tcp.send(remote, data, function(sendInfo) {
                              if (sendInfo.resultCode < 0) {
                                console.log("close " + local + " " + remote);
                                tcp.close(local);
                                tcp.close(remote);
                                delete receiveCallbacks[local];
                                delete receiveCallbacks[remote];
                              }
                            });
                          };
                          remoteToLocal = function(data, error) {
                            if (error) {
                              console.log("close " + local + " " + remote);
                              tcp.close(remote);
                              tcp.close(local);
                              delete receiveCallbacks[local];
                              delete receiveCallbacks[remote];
                              return;
                            }
                            data = encryptor.decrypt(data);
                            return tcp.send(local, data, function(sendInfo) {
                              if (sendInfo.resultCode < 0) {
                                console.log("close " + local + " " + remote);
                                tcp.close(local);
                                tcp.close(remote);
                              }
                            });
                          };
                          read(local, localToRemote);
                          return read(remote, remoteToLocal);
                        });
                      });
                    });
                  });
                });
              });
            };
            return tcpServer.onAccept.addListener(accept);
          });
        });
      });
    }

    Local.prototype.close = function() {
      console.log(this.listen);
      if (this.listen) {
        return tcpServer.close(this.listen);
      }
    };

    return Local;

  })();

  window.Local = Local;

}).call(this);
